1. Node.js 최신 버전 설치 - google에서 설치 (맥 윈도우 동일)
	ㄴ 설치되어 있어도 신버전으로 다시 설치
2. IDE(VSCode) 설치
3. 폴더생성 
4. 에디터로 폴더 오픈
5. terminal열어서 npx create-react-app blog 라고 작성해서 blog라는 폴더로 react 폴더가 생성
	*npx는 라이브러리 설치 명령어 라고 보면 됨 - node.js에 있음 
	*create-react-app - 라이브러리명, 리액트 세팅이 완료된 것을 설치받게 해줌(보일러 플레이트?) - 한번에 설치하게 해준다
6. 하위폴더에 blog가 생성되고 리엑트에 필요한 모든 파일이 설치 됨 

7. blog 오픈해서 시작하면 됨 
8. npm start 해서 시작하면 페이지가 보임


node.js 를 설치하는 이유 create-react-app 라이브러리를 사용하기 위해서 
쓰려면 npm, npx를 사용하라함 
node.js를 설치하면 npm이 라는 툴이 딸려오고 
node.js를 설치한 컴퓨터에서 라이브러리를 쉽게 설치할수 있는 것
npm을 사용해서 create-react-app라는 라이브러리를 쉽게 설치할 수 있는 것임
npm은 유용하니 찾아보셈 
프로젝트 생성 후 여러 파일이 있는데 main 페이지는 app.js임 
실제 메인페이지는 아니고 이 메인페이지에 들어갈 HTML 코드를 짜는 것임 
그럼 실제 메인 페이지는 public 이라는데를 보면 HTML파일이 하나있는데 이게 메인페이지임
근데 보면 이미지나 그런것들이 아무것도 없는데 그럼 이런 것들이 어딨냐하면 app.js에 들어 있음
app.js에 있는걸 index.html에 갖다 박아넣어주세요 라고 명령을 하고 있기에 보이는 것임 
이 넣어주는 명령은 index.js에 들어 있음

node_moduls라는 것은 설치한 라이브러리(create-react-app를 구동시키기 위한 라이브러리) 모두 모여있음
public은 static한 파일들을 보관하는 장소라고 보면 됨
리엑트 프로젝트를 다만들면 빌드 발행 컴파일을 하는데 그떄 파일들이 다 압축되는데 public에 되어 있는건 압축이 안됨 
src는 소스코드 보관함, 실질 코딩은 다 여기서함
package.json은 설치 라이브러리 명과 버전을 다 모아둔 파일임 - 건들필요 없음...npm 설치할때마다 자동으로 바뀜 

----------------------------------------------------------------


1. app.js에서 header라는 부분 다 지워 볼 것임 

index.js가 app.js안에 잇는 html을 public 안에있는 index.html에 넣어줌 (정확하게는 id가 root인 div태그에 app.js를 갖다넣어주세요 되기 떄문에 )
그렇기에 app.js 가 메인이 되는 것임.

보면 app() {} 의 return()안에 태그 넣는 걸로도 됨

상단 메뉴바를 사용해서 jsx라는 문법을 알아보자 .

html이 아니라 jsx라는 문법을 쓰는 것임 .
jsx에는 class를 넣을순 없고 className을 넣어줘야함 


데이터바인딩이 좋아서 이런 프레임 워크를 쓴다고함..

블로그 글이 있는데 맨날 목록이 바뀌기에 서버에서 가져와서 데이터를 변수에 넣고 사용하는데 이런걸 데이터 바인딩이라고 한다
(서버에서 가져온 데이터를 HTML에 받아 쓰는것)
리엑트에선 궂이 바꾸고 변경하고 바인딩을 하는게 쉽다고 함 

바꾸고 싶은걸 찾고, 중괄호를 열어서 변수명을 그대로 치면 됨 

데이터 바인딩이 쉬워짐

스타일 그냥 못집어 넣게 되어 있슴 - 
이유는 자바스크립트에서 쓸수 있는 민감한 기호들이 있기에 스타일은 무조건 중괄호로 넣어줘야하고 Object 형식으로 넣어줘야함 
또한 snakeCase가 아니라 camelCase로 작성해야함

변수에 오브젝트 형태로 넣어주고 변수를 넣어줘도 됨.

------------------------------------
state

글 목록 만들기 

사이트에 필요한 데이터를 보관할때 옵션이 두개가 된느것임 
1. 변수에 저장, 2. state에 저장

변수와 비슷하나 조금 다름

arr 안에 10, 100이 들어 있는데 각각 변수에 담고 싶으면 변수를 만드는데 let [a, b] = [10, 100];
이게 ES6의 destructuring 이라는 문법임. 

State를 쓰는 이유는 react를 웹앱처럼 동작하게 만들기 위해서는 중요한 데이터는 state에 보관해야함
state는 글제목과 같은게 바뀔수 있는데 그럴 경우에 데이터가 바뀌면 state로 만들어진 데이터가 바뀌면 
데이터를 담고 있는 HTML이 자동으로 재 렌더링이 됨 
그냥 변수는 데이터가 바뀌어도 재 렌더링이 바로 되지 않고 새로고침 됨.
state로 만든 데이터는 정렬과 같은 버튼을 누르면, 글수정을 누르면 재 렌더링 됨 - 새로고침 없이 재렌더링 해줌 
웹앱을 만드는 가장 중요한 원칙임 

- 수시로 바뀔만한 요소들에서 state를 넣어주는게 좋음 - 정렬, 수정 등...
그냥 자의로 판단하면됨 

eslint는 잘못된 코딩 관습을 알려주는 거임 
이거 제거 하고 싶으면 /* eslint-disable */이라고 맨상단에 작성해주면 안뜸

state는 그냥 변경하면 안되고 두번째 인자인 변경하는 변수를 써야함 - 근데 이 변수는 함수임
b(변경하고싶어하는 변수); - 근데 그냥 이래 쓰면 무한랜더링이 생성됨
그래서 그냥 쓰는게 아니라 이벤트랑 같이 사용해야 하고 
onClick={()=>{변경변수(변경하고자 하는값)}}
처럼 사용해야함 

let [받을 변수, 변수를 변경할 함수 변수] = useState("받을 변수에 넣고 싶은 값");
onClick={()=>{변수를 변경할 함수 변수(변경하고자 하는값)}}

이런 식으로 사용해야함. 이렇게 사용해야 재 렌더링이 일어남 


Array, Object 같은건 원본을 보관하고 수정하는게 좋음

근데 카피본을 let 글제목카피 = 글제목; 으로 하면 안되고 let 글제목카피 = [...글제목]; 와 같이해야 한다고 함 
그 이유는 ? 
2가지 포인트 이해가 필요함
1. state변경함수의 동작 원리의 이해가 필요함 
소괄호 안에 넣음으로 갈아 치워주는데 이전에 조건을 따져보는데 기존이랑 신규를 등호로 비교해서 같다면 변경을 해주지 않는다 
기존State == 새로운State 
이는 자원 절약을 위한 것임.
2. Array, Object 데이터는 자바스크립트에서 동작방식이 특이함
let arr = [1,2,3] 
이게 자바스크립트에서는 arr에 [1,2,3]배열을 넣어주세요가 아니라 arr이란 변수에  [1,2,3]배열이 존재하는 주소값을 넣어주세요가 맞음

그래서 안되는 이유는 array데이터 수정법은 맞는데 글제목을 타고 들어가서 여자 추천을 바꿔주는데 글제목이 있는 화살표는 절대 변경이 안됨 
그니까 2번에서 본거 처럼 배열변수에 배열에 대한 주소값을 넣어주고 주소값 내부의 값을 변경한다 해서 주소값자체가 변경되지 않기에 
주소값은 그대로임, 근데 1번에 의해서 arr에 담겨 있는 주소값 자체는 변하지 않았기 떄문에 state에서는 값의 변경이 되지 않았다고 인식하고 
변경을 해주지 않는 것임
근데 그럼 복사한건 왜 안되냐..? 
복사할때 그냥 let 복사본 = 원본; 으로 한다면 결국 주소값을 복사 저장하는 거라서 결국 동일한 주소값을 보게 되는 거임.(얕은 복사)
복사본 == 원본 -> true가 나올 거임

[...원본]에서 ...은 전개연산자라고 해서 깊은 복사를 해줌, 또 사용법은 ...을 쓰면 예를 들어 
[1,2,3,4,5,6,7,8,9]라는 배열이 있을때 
let [a,b,c] = [1,2,3,4,5,6,7,8,9]를 넣으면 a,b,c에 각각의 데이터가 하나씩만들어감 1,2,3만 들어가고 나머지는 안들어가는데 
let [a,b,...c] = [1,2,3,4,5,6,7,8,9]로 받아주면 a,b에는 1,2가 각각들어가고 c에서는 나머지 배열들이 모두 들어가게 된다..
또 좋은 점은 
예를들어 arr이라는 배열에 c를 넣어줄건데 거기에 10을 추가하고 싶다면 아래와 같은 방식으로도 추가가 가능하다 
let arr = [...c, 10]

어어메이징!

리엑트 라우터 

-------------------------------------------------
리엑트에서는 HTML덩어리들을 축약할수 있는 컴포넌트 문법이 있다.
<Modal></Modal>마냥

컴포넌트를 만드는 법은 function만들고, return() 안에 HTML을 담고 <함수명></함수명>쓰기
function은 app function외부에 만들어야함, 그리고 함수명은 대문자로 시작

그리고 최상위 태그는 무조건 한세트만 있어야함
function Modal(){
  return(
  <div className='modal'>
    <h4>제목</h4>
    <p>날짜</p>
    <p>상세내용</p>
  </div> 
  );
}
만약 여러개를 쓰고 싶은데 의미 없는 div태그를 늘리기 싫다면 
function Modal(){
  return(
	<>
	  <div className='modal'>
		<h4>제목</h4>
		<p>날짜</p>
		<p>상세내용</p>
	  </div> 
	</>
  );
}
(<></>를 최상위에)이렇게 넣어주면 됨 

<함수명></함수명>은 <함수명/>과 같이 사용해도 됨

근데 이런거는 언제 쓰면 좋은가? 3가지를 말해보자면 
1. 반복적으로 출현하는 HTML은 컴포넌트로 만들어두면 편함 
2. 페이지 전환을 할때 큰페이지 하나같은 경우도 컴포넌트 하나로 써도 좋음
3. 자주 변경되는 HTML ui들도 컴포넌트로 만들어두면 좋을수 있음(성능상 .. 그러나 항상 그런건 아님)

컴포넌트를 막만들면 안되는데 만약에 데이터 바인딩{변수}를 하려면 어떻게 하는가? 
그냥 쓰면 안뜸; 왜냐면 새로생성한 컴포넌트 함수가 아니라 app함수안에 있기 떄문임
컴포넌트를 많이 갖다가 쓰면 문제가 생길 요소가 많음.. 그러니가 잘써야함 
state를 갖다 쓰면 불편할것들이 있음..
너무 더럽거나 자주나오는 것만 컴포넌트로 만드는게 좋음 

function을 만들때 
let Modal = () => {
	return(
	
	);
} 
처럼 만들어도 되는데 
저렇게 만들면 const로 만듦, 왜나면 변경될때 에러만들어주면서 왜 이거 바꿀라하냐 그렇게 에러 만들어줘서 확인이 편해짐 


리엑트에서 라우팅 처리란
브라우저 URL이 변할때 마다 보여줄 컴포넌트를 맵핑하고 렌더링 하는 과정을 의미함
그니까 메뉴 같은걸 눌러서 다른 페이지도 이동하는 것처럼 하는걸 라우팅 처리한다고함
리엑트에서 라우팅 처리를 하려면 추가적으로 모듈이 필요함 

npm install react-router-dom@버전 - 저장되는 폴더 위치에서 
6버전을 설치하겠다 npm install react-router-dom@6 이렇게 하면 됨

그러고 index.js에 ReactDOM import 문 아래에 import {BrowserRouter} from 'react-router-dom' 와 같이 작성함 
BrowserRouter을 가져오겠다는 것임, BrowserRouter는 웹브라우저 라우팅에 가장 많이 쓰는 보편적인 라우터라고 보면 됨 
그러고 하단에 React.StrictMode의 바로 하단자식들을 모두 <BrowserRouter> 태그로 감싼다
그리고 App.js에 import {Routes, Route, Link} from 'react-router-dom';로 react-router-dom에 Routes, Route, Link를 가져온다
그러면 이제 App.js에 Link라는 태그를 사용할 수 있게됨, 이는 a태그와 기능이 비슷함, 나중에 브라우저에 올라가면 a태그로 바뀌어 나옴


      <nav>
        <Link to='/'>home</Link>
        <Link to='/about'>about</Link>
      </nav>
      <Routes>
        <Route path='/' element={<Home/>}/>
        <Route path='/about' element={<About/>}/>
      </Routes>
	  이런식으로 쓰면 됨 
	  
	  
	  링크에서 to에있는 path를 가진 동일한 라우트를 찾고 라우트는 해당하는 걸 눌렀을때 element를 보여준다.
	  
	  
3. 
 {showTimer && <Timer/>} - showTimer가 true 라면 <Timer/>를 보여줘라
 
 
4. useRef란?

useRef는 리액트의 훅(Hook) 중 하나로, DOM 요소에 접근하거나 컴포넌트 내에서 변수를 유지할 수 있는 기능을 제공합니다. useRef를 사용하면 함수 컴포넌트에서도 클래스 컴포넌트의 this와 유사한 기능을 수행할 수 있습니다.

이전에 자바스크립트로 DOM을 querySelector를 사용해서 사용했다면 React에서는 useRef를 사용한다고 보면 된다.

useRef(value)를 쓰면 ref 오브젝트를 반환한다 {current:value}

ref오브젝트는 수정이 가능하기에 언제든 바꿀수 있고 컴포넌트의 전 생애 주기에서 유지한다(언마운트 될때까지 )
그럼언제 사용되는가? 스테이트처럼 값을 저장하는 저장공간으로도 사용됨

State의 변환 -> 렌더링 -> 컴포넌트 내부 변수들 초기화
Ref의 변화 -> No렌더링 -> 변수들의 값이 유지됨

ref를 사용하면 불필요한 렌더링을 막음, 또한 
state의 변화 -> 렌더링 -> 그래도 Ref의 값은 유지됨 - state가 변화해도 Ref값을 유지시킴
변경시 렌더링을 발생하지 말하야 하는 값을 다룰때 좋음 

Ref는 Dom요소에 접근할때 사용될수 있음, input 요소를 클릭하지 않아도 포커스를 줄때, 로그인 할때 자동 포커스를 주는 경우 같은..

리액트에서 스테이트가 변경된다는 것은 다시 렌더링이 된다는 의미임, 그의미는 함수형 컴포넌트에서 
App이라는 함수가 다시 불려진다는 의미임, 그렇기에 console.log()를 찍어보면 렌더링이 불림
실시간으로 볼수 있는건 계속 렌더링이 되기 떄문임 

5. useRef를 이용해서 Dom요소에 접근하기

ref오브젝트를 접근하려는 요소의 태그의 ref 속성에 넣으면 쉽게 접근이 가능함 

대표적인 usecase로는 input 태그에 focus를 줄때 많이 사용함 

로그인시 로딩될때 화면에 보여질때 자동적으로 포커스를 주듯이 .

6. useContext, Context API

리액트로 만든 앱은 여러 컴포넌트로 이루어져 있다.
최상위 App 부터 트리형태로 쭉쭉 뻣어 내려간다. 리액트에서의 일반적인 데이터 흐름은 위에서 아래로, 부모 컴포넌트에서 
자식컴포넌트로 props를 통해 전달이 된다.
props로 데이터를 전달할 때는 부모 컴포넌트가 자식 컴포넌트의 태그에 props를 일일이 넣어서 단계별로 전달이 된다
(이런 것을 prop drilling 이라고 함, 상위 컴포넌트가 갖고 있는 데이터를 하위 컴포넌트에게 props로 전달하여 데이터가 필요한 컴포넌트까지 단계별로 내려가는 과정)

그럼 수만은 컴포넌트가 존재할 때 전역적으로 필요한 데이터들(사용자 정보, 테마, 언어등...)이 존재 할 텐데 이런 전역적인 데이터를 props로 일일이 전달해야 한다면 큰 고통이 따라올 것이다..
이러한 문제점을 Context API를 통해 간편하게 해결할 수 있다.
컨텍스트를 사용할 때 props로 일일이 데이터를 전달하지 않아도 해당 데이터를 갖고 있는 상위 컴포넌트가 데이터가 필요한 컴포넌트에게 알릴수 있고 하위 컴포넌트들은 트리안에 어디에 위치하고 있어도 데이터가 필요하다면 해당 값에 겁근 할 수 있다. 그렇기에 전역적인 데이터를 전달하기에 편리하다.

prop drilling은 가장 하위 단계 컴포넌트가 필요하더라도 중간 컴포넌트들이 모두 가져야만 하게 되는데 이러면 컴포넌트가 받는 props가 많고 코드도 많아지고 중간 수정이 된다면 에러를 처리하기 위해서 고생할 것이다

이때도 상위 컴포넌트가 context API를 통해 알리면 하위 컴포넌트에서는 useContext를 사용해서 갖다 쓰기만 하면 되는 것임

그러면 props는 왜쓰냐..? context를 사용하면 컴포넌트를 재사용 하기 어려워 질 수 있기에 꼭 필요할 때만 context를 쓰는게 좋다. prop drilling을 방지하기 위함 이라기 보다는 다양한 컴포넌트가 공통된 데이터를 상위 컴포넌트에 요청할 경우에 사용하기 좋은것임. prop drilling 을 피라기 위함이라면 Component Composition을 먼저 고려해 봐야함.

