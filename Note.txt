8.7)Delete - 투두 삭제하기

지금까지 만든 todo list에 있는 모든 todo에는 각각 삭제버튼이 존재한다. 그래서 이버튼을 클릭하게 되면 todo item이 이 리스트에서 제거가 되어야한다. 결국 이번에 만드는 기능 또한 todos state내부에 값을 수정하는 것이다. 그렇기에 onUpdate함수를 만든것 처럼 onDelete를 생성해주고 매개변수로 target.id를 받아와서 해당 id를 갖는 todoitem을 todos state에서 제거해주면 된다.
setTodos()의 인수로 target.id와 동일한 id를 갖는 요소를 삭제한 배열을 넣어주면 된다. 그래서 기존 배열에서 이런 조건을 만족하는 요소만 딱 제외하고 나머지 요소들로만 필터링하기 위해서 todos의 filter메서드를 사용하면된다. 그리고 callback함수로는 모든 todos를 순회하면서 3항연산자로 todo의 id값이 target.id와 같지 않은 todo만 필터링하도록 만들어주면 된다. 그러면 삭제되어야하는 item만 제외한 새로운 배열을 만들어서 인수로 전달해줄 수 있기에 결과적으론 해당 아이템이 todos state에서 잘 제거가 된다.

그러면 이제 이 함수는 어디에서 호출이되어야 하냐면 todoitem컴포넌트의 삭제버튼이 클릭되었을때 삭제가 되어야하기에 update를 만들때와 동일하게 리스트 컴포넌트 안에 todoitem컴포넌트 안에 버튼이 클릭되었을때 호출해주면 된다. 이전에 했던 것과 같이 App컴포넌트에서  onDelete함수를 List컴포넌트에게 먼저 props로 전달해주고 List컴포넌트는 이함수를 props로 받아서 todoitem컴포넌트에게 props로 전달하고 todoitem컴포넌트에서 똑같이 props로 받아서 버튼을 클릭할때 호출되면서 인수로 id를 전달해주면된다. 
그래서 먼저 onClickDelete라는 함수를 만들어서 이 함수에서 onDelete함수를 호출하고 인수로 id를 전달하도록 만들면서 onClickDelete 함수를 삭제버튼의 onClick함수의 이벤트 핸들러로 등록을 해주면 된다.


todo list를 구현하면서 배운점

display:flex = todoitem.css 원하는 요소를 가로로배치하는 법을 배움
배열형태의 데이터를 만들어서 list형태로 렌더링하는 방법 
데이터를 추가, 제거, 수정, 검색하는 방법을 배움
-----

섹션 9. useReducer
9.1) useReducer를 소개합니다.
useReducer라는 새로운 리액트 hook을 배워보자.

section08을 이용해서 사용할 것이다. 우선 이걸 복사해서 section09디렉터리를 만들고 넣어주자.
useReducer는 useState와 동일하게 컴포넌트 내부에 새로운 state를 생성하는 리액트 hook이다.
그렇기에 지금까지 만들어둔 useReducer를 이용해서도 동일하게 만들수 있는데 그렇기에 useState와 거의 비슷한 기능을 한다.
useReducer를 이용하면 useState와는 달리 상태를 관리하는 코드들을 컴포넌트 외부로 분리할 수 있다는 핵심적인 차이점이 있다.
원래 우리가 useState를 이용할때는 onCreate와 같이 state를 관리하는 코드, 상태를 관리하는 코드들을 컴포넌트 내부에만 작성해야 했으나 useReducer를 이용하면 컴포넌트 내부에서는 state생성만 해두고 실제로 state를 관리하는 코드들은 reducer라는 함수를 통해서 컴포넌트 외부에서 관리하도록 코드를 분리할 수 있다. 

우리가 이전 섹션에서 todolist프로젝트르 개발할때 todo데이터를 관리하는 state를 App컴포넌트내부에 useState를 이용해서 만들었는데 이렇게 되면 todos와 setTodos라는 함수는 App컴포넌트 내부에서만 사용할 수 있기에 이 state를 관리하는 코드들은 반드시 App컴포넌트 내부에만 작성이 되어야했다. 그렇기에 이렇게 state에 새로운 값을 추가하는 onCreate나 state에 특정값을 수정하는 onUpdate나 state에 특정값을 제거하는 onDelete와 같은 todos state를 관리하는 코드들을 반드시 App컴포넌트 내부에 작성이 되어 있어야 했다. setTodos같은 함수나 todos같은 state는 아까 말했던거서럼 App컴포넌트를 벗어난 공간에서는 접근할 수 없기 때문이다. 
그런데 그러다보니 컴포넌트 내부에 상태관리 코드들이 너무 길어지게 되었다. 그래서 지금도 충분히 기나 현재보다 더 복잡해지거나 훨씬더 다양한 상태변화를 제공하는 경우에는 컴포넌트 내부에 훨씬더 긴 코드를 작성해야한다. 그런게 리액트 컴포넌트의 가장 주된역할은 UI를 렌더링하는 역할이다. 그렇기에 이렇게 state를 관리하는 코드가 너무 많아지면 사실상 주객이 전도된것이다. UI를 렌더링하는 코드보다 상태를 관리하는 코드들이 훨씬더 복잡하고 길어기 때문이다. 그렇기에 App컴포넌트가 렌더링하는 요소가 무엇인지 한눈에 파악하기 어렵다. 그러면 가독성이 떨어지고 유지보수가 어려워지게 된다. 그렇기에 결국 우린 상태를 관리하는 코드들이 점점 길어지고 복잡해져야한다면 이런 코드들을 별도의 함수로써 분리해줄 필요가 있다. 그러나 useState를 이용하면 이런 기능을 만들 수 없기에 이럴때 컴포넌트 내부의 상태관리를 분리시킬수 있도록 만들어주는 useReducer가 필요한 것이다.

이번에 App컴포넌트의 todos를 useState가 아니라 useReducer를 이용하도록 바꿀 것인데 처음부터 이렇게 큰 state를 바꾸면 너무 어렵기에 일단 실습을 위한 컴포넌트를 만들고 그 컴포넌트 내부에서 useReducer의 사용법을 알아보자.
src/components/Exam.jsx를 만들고 컴포넌트를 만들어주자. 그리고 App컴포넌트에서 import시켜주고 App컴포넌트의 return문 내부를 일단 모두 주석 처리한 후에 Exam태그를 넣어주자.

이제 Exam컴포넌트에서 useReducer를 실습해보기로 하자. 먼저 간단한 Counter기능을 만들어보자. return문 안에 h1으로 counter를 0으로 표시하고 버튼을 하나만들어서 +라고 넣어주자.

그리고 이제 useReducer를 이용해서 새로운 state를 생성해보자. 가장 먼저 useReducer를 불러오고 컴포넌트안에서 
const [state, dispath] = useReducer()로 useReducer hook을 호출해주면 일단 useState와 동일하게 새로운 state를 생성해서 배열의 첫번째 요소에 반환해주는데 dispatch라고 불리는 상태변화를 요청하기만 하는 함수를 반환해준다. 참고로 이때 dispatch라는 뜻은 발송하다, 급송하다 라는 뜻을 가지고 있다. 그렇기에 결국 dispatch함수는 상태변화가 있어야 한다는 사실을 알리는, 발송하는 함수라고 생각하면 된다.
이제 이 컴포넌트 내부에서 dispatch함수를 호출하면 상태변화를 요청하고, useReducer가 상태변화를 실제로 처리하게될 함수를 호출하는데 그 함수는 우리가 직접 만들어야한다. 컴포넌트 밖에 function reducer로 함수를 만들고 useReducer()의 인수로 useReducer(reducer)라고 넣어주면 된다. 이때 참고로 reducer라는 말은 우리말로 변환기라는 의미를 갖는다. 결국 reducer는 상태를 실제로 변화시키는 변환기 역할을 하는 함수라고 이해하면된다. 그래서 useReducer의 첫번째 인수로는 상태를 실제로 변화시키는 변환기역할을 하는 reducer라는 함수를 만들어 넣어주면되고 두번째인수로는 state의 초기값을 전달해준다. 그래서 useReducer(reducer, 0)이렇게 전달해준 다음에 h1태그 안에 state의 값을 렌더링해주게 해주면 화면에 0이 잘 렌더링되는 것을 볼 수 있다. 그러면 이제 버튼을 클릭하면 state의 값을 1씩 증가해줘야하니까 컴포넌트 내부에서 버튼이 클릭되었을때 dispatch함수를 호출해서 상태변화를 요청(발송)하면 된다. 그렇기에 컴포넌트 안에 onClickPlus라는 함수를 만들어서 button의 onClick이벤트에 등록해주고 함수 안에서 dispatch를 호출해서 상태변화를 요청하는데 인수로는 상태가 어떻게 변화되길 원하는지에 대한 정보를 주게될텐데 그렇기에 보통은 dispatch함수에는 객체의 형태로 타입이라는 property에는 상태를 어덯게 변화시키기를 원하는지를 작성한다. 우리는 +버튼을 눌렀을때 state의 값을 1증가시키길 원하는것이기에 문자열로 increase라고 작성해주자. 그리고 얼마나 증가시킬지 명시를 해줘야 하기에 data라는 property로 1만큼 증가시키라고 넣어주자.
그래서 이 코드는 지금 일단은 dispatch로 상태변화를 요청했고 그 요청의 결과로 객체를 전달했는데 이 객체 안에 type은 increase로 값을 증가시키겠다고 작성했고 얼만큼 증가시킬지 data:1로 1만큼 증가시키겠다고 한것임. 그렇기에 이렇게 인수로 전달된 요청에 내용을 담은 객체를 action객체 라고 부른다. 이렇게 action객체를 인수로 전달하면서 dispatch를 호출해주면 useReducer가 요청을 처리하기 위해서 reducer함수를 호출해주고 reducer함수의 매개변수로는 현재의 state값을 전달하고 요청의 내용이 담긴 action객체를 전달해준다. 그래서 다시 정리하자면 dispatch함수를 호출해주면 reducer 함수가 호출되고 그때 action객체가 매개변수로 전달이 된다. 그렇기에 reducer함수 안에 시험삼아서 console.log로 state와 action을 출력하도록 하고 browser에서 개발자도구에 console탭을 키고 +버튼을 눌러보면 출력이 잘 되는 것을 볼 수 있다. 그래서 code상에 reducer함수에서는 매개변수로 받은 현재의 state값고 action객체를 이용해서 실제로 state의 값을 변경시켜주면 된다. 그런데 이렇게 상태변화 함수도 없는데 어떻게 state를 변경할 수 있는가 하면, 그냥 reducer함수에서 새로운 state값을 그냥 반환해주기만 하면 된다. 그러면 반환값을 useReducer가 불러와서 실제로 state값을 변경시켜주게 된다. 그렇기에 reducer함수안에 if조건문으로 action객체의 타입이 increase라고 들어오면 이런 형태로 dispatch를 날린거고 그건 +버튼을 누른것이기에 새로운 state값으로 return state + action.data라고 해서 현재 state의 값에 action객체에 data라고 전달한 값을 더해서 반환을 해주면 된다.

그러면 새로운 상태변화를 추가로 만들어보자. return문 안에 button을 추가해주고 이번엔 -를 추가하고 onClickMinus를 만들어서 onClick의 이벤트 핸들러로 적용시켜주고 dispatch를 호출하고 action객체로 타입은 -1을 해줄 것이기에 decrease, data는 1만큼 감소시키라는 의미로 1을 전달해주자. 그리고 reducer에는 else if로 action.type이 decrease일때는 return state - action.data로 return을 해주자.

이 때 참고로 reducer함수 내부에 action들의 타입이 너무 많아질것 같다면 if문 보다는 switch문으로 작성하는것이 일반적이다(switch 문으로 수정하자.)

-----

9.2) 투두 리스트 업그레이드
useReducer를 todoList에 적용해서 업그레이드 해보자.
Exam컴포넌트를 제거하고 주석을 풀어주고 App컴포넌트의 내부에 todos state를 useReducer로 변경해보자.
useReducer를 불러오고 App컴포넌트안에서 useState라인을 지우고 const [todos, dispatch] = useReducer();를 하고 App컴포넌트 외부에 fuction reducer를 생성하고 useReducer의 첫번째 인수로 전달해주자. 그러면 이제 todos state의 상태변화는 실질적으로 reducer함수가 담당할 것이다. 그리고 두번째 인수로는 mockData를 전달해서 초기값으로 3개의 객체배열로 설정해주자. 그러면 일단 useState를 이용하던 todos state를 useReducer를 이용하도록 변경했다. 이제 onCreate, onUpdate, onDelete와 같은 상태변화함수들의 코드들을 전부 reducer함수에 옮겨주고 dispatch함수만 호출하도록 변형해주자. 먼저 onCreate부터 해보자면 내부를 모두 지우고 dispatch를 호출하고 action객체로 type은 create, data로는 새롭게 생성할 todo아이템을 객체로 넣어주면된다. 기존처럼 내용을 넣어준다. 그러면 이제 브라우저에 todo editor에서 추가버튼을 클릭하면 onCreate를 호출하고 dispatch함수를 호출하게 될것이고 결과로 reducer함수를 호출하게 될것이다. 이제 reducer함수에서는 매개변수로 현재 state값과 action객체를 받아와서 action객체의 값에 따라 변화된 state의 값을 return해주면 되기에 switch를 통해서 action.type이 create일때는 App컴포넌트에서는 이렇게 todo item을 생성해달라고 요청을 보낸것이기에 새로운 state의 값에 새로운 배열을 반환할 것인데 첫번째 요소에는 새롭게 추가될 데이터인 action.data를 넣고 ...state로 기존의 state의 값을 그대로 펼쳐주면 된다. 참고로 action.data는 onCreate함수에서 dispatch로 전달한 새로운 todo아이템일것이다.

이렇게 새로운 데이터를 생성하는 기능을 useReducer로 변경했고 onUpdate를 바꿔주자. 
setTodos함수는 없기에 전부 지우고 onCreate할때 처럼 dispatch를 호출하고 type을 update로 지정하고 data보다는 target.id로 어떤 요소를 수정할지만 전달해주자. 그러면 reducer함수에서는 case로 action.type이 update일때 return으로 state의 기존값에서 map메서드를 이용해서 state안의 id와 action.id와 같다면 3항연산자로 변형된 배열을 반환하도록 하면 된다.
...item으로 기존 값을 나열해주고 isDone property값만 isDone으로 토글시켜주면 된다. 만약 조건이 거짓이면 그냥 item을 return하도록하면 된다. 이러면 action.target.id를 갖는 것만 isDone이 반전, 토글이 될것이고 나머지 요소들은 그대로 유지가 될것이다.

onDelete도 useReducer를 이용하도록 바꾸자.
dispatch함수를 호출하고 type은 delete를 전달하고 target.id로는 매개변수로 받은 id를 넣어주고 reducer함수에서 case가 delete라면 return에 state.filter로 item의 id가 action.target.id와 같지 않은 요소만 필터링하면 된다.

마지막으로 그 셋다(create, update, delete)가 아니라면 default로 state를 기본으로 반환하도록 하자.

 
보통은 리액트에서 state를 관리할때는 배열안에 객체가 들어가는 복잡한 구조는 useReducer를 이용하는게 보편적이고 counter처럼 간단한경우는 useState로 하는것이 충분하다.

-----

섹션 10 최적화

10.1) 최적화란

최적화란 서비스의 성능을 개선하는 모든 행위를 말함.
웹 서비스의 최적화란 아주 단순한것 부터 아주 어려운것 까지 다양한 방법이 있는데 서버의 응답속도를 개선한다던가, 이미지나 폰트 등의 정적 파일들의 로딩속도를 빠르게 만든다던가 또는 불필요한 네트워크 요청을 줄인다던가 하는 일반적인 모든 웹 서비스들에 다 적용할 수 있는 최적화 방법도 있고 컴포넌트 내부에 불필요한 연산을 방지한다던가 컴포넌트 내부에 어떤 함수를 다시 생성하지 않도록 막아준다던가 컴포넌트가 딱 필요한 순간에만 리 랜더링되도록 불필요한 리렌더링을 방지하는 것과같은 리액트 내부에서만 수행하는 특별한 최적화 방법도 존재한다. 또 리액트에 대한 내용을 심도 있게 다루기에 리액트 컴포넌트 내부에서만 진행 가능한 리액트만의 세가지 최적화 방법에 대해서 하나씩 알아보자.
마지막으로 새로운 리액트 앱을 세팅해보자. 이번 섹션에서도 새로운 프로젝트를 진행할 건 아니기에 todolist앱을 그대로 이용할 것임. section10을 만들고 복사해서 만들어 두자.

---
10.2) useMemo와 연산최적화

useMemo라는 새로운 리액트 hook을 이용해서 컴포넌트 내부에 불필요한 연산을 다시 수행하지 않도록 최적화하는방법을 살펴보자.
우선 useMemo는 memoization이라는 방식을 기반으로 불필요한 연산을 다시 수행하지 않도록 리액트 앱을 최적화해주는 리액트 hook이다. Memoization이란 기억해두기, 메모해두기란뜻을갖는데 프로그램에서 동일한 연산을 반복적으로 수행해야할때 결과값을 매번 새롭게 계산하는 방식이 아니라, 최초로 한번 계산할 때의 결과값을 메모리 어딘가 보관해둔 다음에 다시 이 연산이 필요한 경우 저장된 값을 돌려주는 기법을 말한다.
Memoization기법을 이용하면 최초에 수행 이후엔 결과값을 저장한 다음에 매번 동일한연산을 불필요하게 수행할 필요가 없기에 프로그래밍의 성능이 나빠지지 않는다.
예를 들어  사람이 아주 많은 식당에서 식사를 하는데 우리가 시킨 메뉴가 엄청 독특하다면 지나가는 사람마다 메뉴가 뭔지 물어본다. 이런 질문을 받을때마다 내가 뭘 시켰는지 메뉴판에서 찾아보고 다시 대답을 해주지 않는다. 보통은 한번 주문하면 메뉴의 이름을 외우기 때문에(Memoization) 바로 머리속에 있는 정보를 꺼내오기만 해서 메뉴의 이름을 답변해준다. 바로 이게 Memoization이다. 그리고 리액트에서는 useMemo를 이용해서 이 Memoization기법을 이용해서 결과값을 기억할 수 있게 된다.
useMemo를 이용해서 컴포넌트 내부에 불필요한 연산을 방지하여 최적화하는 방법을 알아보자. 이전에 만들었던 todolist app에는 당장은 불필요한 연산이없다. 그렇기에 List컴포넌트 안에 현재의 todo들의 상태를 분석해서 수치를 제공하는 함수를 만들어보자. 컴포넌트맨아래 return문 위에 const getAnalizedData라는 화살표 함수를 만들고 함수 내부에 const totalCount라고 해서 현재 등록된 전체 todoitem의 갯수를 저장해보자. 그래서 todos state에 length라는 값으로 초기화를 해주고 const doneCount라고 해서 전체 todo중 완료된 todo의 갯수를 저장할 것인데 값으로는 todos.filter메서드를 사용해서 callback함수로 todo.isDone이 true인 아이템들만 필터링해서 length로 길이를 저장해두자. 그리고 마지막으로 const notDoneCount로 완료되지 않은 todo의 갯수를 저장해보자. totalCount에서 doneCount를 뺀값을 저장해주자.  그리고 세가지를 RETURN객체로 묶어서 내보내주자. 그러면 이제 List컴포넌트가 리렌더링 될때마다 List컴포넌트 안에서 RETURN문 위에 getAnalizedData함수를 호출해주고 그결과값을 구조분해할당을 이용해서 순서대로 totalCount, doneCount, notDoneCount를 받아와주자. 그리고 나서 이렇게 구한 수치값들을 렌더링해주기 위해 컴포넌트 return문안에 h2태그 아래에 div태그를 하나 선언하고 그 내부에 div로 total = {totalCount} done={doneCount}, notDong={notDoneCount}라고 적어주자. 그러면 이제 브라우저에 새로고침해보면 분석된 수치값들이 잘 렌더링 될 것이다.

이렇게 리스트 컴포넌트에 새로운 기능인 현재 todo를 분석하는 함수를 만들었는데 이때 이 연산과정은 filter라는 메서드를 이용하고 있기에 todo state에 보관된 data의 갯수가 증가하면 증가할 수록 훨씬더 오래걸리는 함수가 될것이다. (filter메서드는 전체 요소를 한번씩 순회하기 때문임.) 그래서 최대한 이 함수가 불필요하게 호출되는 상황을 방지해야 하는데 이 함수는 컴포넌트 내에서 그냥 바로 호출하고 있기에 List컴포넌트가 리렌더링될때마다 계속 새롭게 호출이 될것이다. getAnalizedData()함수 맨 위에 console.log("getAnalizedData() 호출")을 작성해주고 보면 List컴포넌트가 최초에 렌더링될때 한번 출력이 되고 List컴포넌트안에서 state를 관리하고 있는 search bar에 react라고 검색해보면 콘솔에 메세지가 5회 발생하는것을 보면 리렌더링 횟수만큼 함수가 호출 되는것을 알 수 있다. 
이건 명백한 낭비이다.  왜냐면 search bar에 뭔가를 검색한다고 todo에 대한 정보가 변경되는 것이 아니기에 계속 조회해야할 필요가 없다. 추가, 수정, 삭제시에만 다시 호출하는게 맞기에 연산자체를 memoization할 수 있는 방법이 필요한데 이럴때 useMemo를 사용하는 것이다. 
useMemo를 사용하면 이 연산 자체를 Memoization 할 수있고 특정 조건이 만족할 때에만 결과값을 다시 계산하게 설정할 수 있다.
useMemo를 먼저 import하고 컴포넌트 내부에 useMemo를 호출해주고 첫번째 인수로 callback함수를 넣고 두번째 인수로 배열을 넣어주면 되는데 두번째 인수가 deps(의존성배열)이다. useEffect처럼 deps에 포함된 값이 변경되었을때만 callback함수를 다시실행하고 그리고 그 callback함수가 반환하는 값을 useMemo가 그대로 반환해준다. 그냥 return 1을 해주면 그 결과값을 받아서 사용까지할 수 있는 hook이다.
그렇기에 useMemo의 첫번째 매개변수, callback함수에는 Memoization하고 싶은 내용을 적어주면 되는데 우리는 getAnalizedData함수의 내용을 그대로 넣어주자. 그러면 useMemo는 우리가 첫번째 인수로 전달한 callback함수가 반환하는 값을 그대로 반환해준다. 그래서 결국 이렇게 호출한 useMemo의 반환값은 이 객체이기 때문에 getAnalizedData를 호출했을때 했던것 처럼 동일하게 const [totalCount, doneCount, notDoneCount] = useMemo(.. 도 가능하다. 그리고 getAnalizedData함수도 useMemo안에서 연산을 하기에 필요가 없어진다.

지금까지 나온 useMemo에 대한 내용은 

1. 첫번째 인수로 전달한 Callback함수는 내부에서 발생한 결과값을 그대로 반환해준다.
2. 첫번째 인수로 전달한 Callback함수의 내용을 Memoization한다.

이러면 메세지는 딱한번만 출력이 되면서 useMemo는 딱한번만 출력이 된다. 그런데 이때 경고메세지가 나오는데 난 발생을 안함(아마 콜백함수 안에 배열을 안넣어서 그런듯 - 그건 아니고 뭔가 문제가 있는듯 - 보니까 콘솔 에러가 아니라 에러 관련 부분에서 나오는 것을 말하는듯함)

빈 배열로는 값이 변화해도 반영이 되지 않기 때문에 deps에 todos를 추가해주면 끝이다.



------


10.3) React.memo와 컴포넌트 렌더링 최적화
Memo라는 리액트 내장 메서드를 사용해서 컴포넌트의 불필요한 리렌더링을 방지하는 방법을 알아보자.
React.memo는 리액트의 내장함수로 인수로 리액트의 컴포넌트를 받아서 해당 컴포넌트의 최적화 기능을 추가한 다음에 결과값으로 반환해준다. 이렇게 최적화 기능을 추가한 기능은 props를 기준으로 Memoization된다. 구체적으로는 Memoized 컴포넌트는 부모 컴포넌트가 리렌더링되더라도 자신이 받는 props가 바뀌지않으면 다시는 리렌더링이 발생하지 않도록 Memoization되기에 불필요한 리렌더링이 방지되어 자동으로 최적화가 이루어진다. 
이번에 실습을 위해 Todo List에서 어떤것이 불필요한지 확인해보자. 개발자도구에 컴포넌트에서 톱니바퀴를 눌러서 setting 창을 열고 렌더되는 요소에 하이라이틀주는 옵션을 켜주고 확인해보자. 이렇게 설정했다면 개발자도구를 끄지말고 확인해볼것이다.
상단에 Header, Editor, List 모두 리렌더링이 발생한다. 이렇게 todo data를 수정하면 모든 컴포넌트가 리렌더링된다.
근데 보면 Header 컴포넌트는 리렌더링 될 필요가 없다. App컴포넌트의 자식으로 베치되어 있기에 부모 컴포넌트를 따라서 자식이 리렌더링 되고 있는 것인데 보면 props로 아무런값도 받지 않고 Header컴포넌트는는 date객체 하나만 렌더링하는 기능만 존재하기에 todo data가 수정된다고 해서 이 컴포넌트가 다시 렌더링 되어야할 필요가 없다. 그래서 Header컴포넌트의 불필요한 리렌더링을 방지하기 위해서 앞서 소개한 React.memo를 살펴볼것이다.


Header컴포넌트로 이동해서 먼저 메모를 import해보자.

import { memo } from 'react'

로 메모 메서드를 불러오고 파일의 하단에 컴포넌트 밖에서 memo메서드를 호출하고 인수로는 최적화하고자 하는 컴포넌트인 Header를 넣어주면 된다.
 
memo(Header);

그러면 이제 memo메서드는 인수로 받은 Header컴포넌트를 props가 변경되지 않은 경우 리렌더링 하지 않도록 최적화해서 반환해주기에 그 반환값을 const memoizedHeader라는 변수에 저장해주고 export에서 Header가 아니라 최적화가 이루어진 헤더 컴포넌트인 memoizedHeader를 내보내주면 된다. 이때 이런 경고 메세지가 발생하는데 이 경고메세지는 리액트의 동작에는 영향을 주지 않아서 무시해도 되나 신경쓰인다면 마우스 커서를 올려놓으면 경고 메세지를 볼 수 있다. 안에 적혀 있는 것은 ESLint의 옵션이 나와있는데 그냥 이 옵션을 끄면 된다. 소괄호 안의 옵션을 복사해서 rules안에 새로운 옵션으로 추가하고 off를 값으로 추가하면 옵션이 꺼져서 문제가 사라진다.

이렇게 React.memo를 이용해서 불필요한 리렌더링을 방지하는 최적화를 해봤다. 
(export default memo(Header);로 넣어도 문제는 없이 사용된다.)

하나 더해보자면 아이템의 체크박스를 껐다가 켜보면 빨래하기랑 체크박스를 선택하지 않은 컴포넌트들도 리렌더링이 발생한다. 이 또한 불필요한 리렌더링이기에 수정을 해보자.

Todoitem컴포넌트로 이동해서 props가 변경되지 않았을때는 리렌더링 되지 않도록 memo메서드를 이용해서 최적화해보자.
파일 상단에 memo를 import해주고 파일 최하단에 memo(Todoitem)으로 내보내보자. 
그러면 이제 Todoitem컴포넌트는 자신이 받고 있는 props가 변경되지 않는 이상 렌더링이 발생하지 않을것이다.

근데 실제로 껐다가 켰다 해보면 모두 리렌더링 되는 것을 볼 수 있다. 이건 memo메서드가 제대로 동작하지 않는것 처럼 보인다. 왜 이러는 것일까? 
memo는 사실 제대로 수행했다. 우리가 checkbox를 클릭해서 todos data를 변경하면(App컴포넌트안의 todos의 데이터를 바꾸면) 리렌더링 되고 App함수가 재 호출되고 함수 내부의 onCreate, onUpdate, onDelete도 다시 새롭게 만들어진다. 그런데 함수는 객체타입이기에 같은 동작을 하더라도 새로 생성될때마다 아예 다른 값으로 인식한다. 그 이유는 자바스크립트에서 객체자료형을 살펴볼때 함수들은 객체 자료형에 해당하기 때문에 우리의 값은 주소값으로써 저장이된다고 배웠었다. 그리고 그 객체들간의 비교는 이 주소값을 통해서 비교한다고했었기에 const a = {a:1} const b = {a:1} 일때도 내부가 완전히 같은 것이더라도 생성될때마다 주소값이 다르기에 console.log로 값을 비교해보면 브라우저의 콘솔에 false로 서로 다른객체로 평가한다고 했었다. 그렇기에 객체 타입인 함수도 컴포넌트가 리렌더링되면서 새로 다시 생성되면 주소값이 계속 바뀌기에 사실상 매번 다른것으로 인식하는 것이다. 그렇기에 Todoitem에 전달되는 onUpdate와 onDelete도 매번 앱 컴포넌트가 리렌더링 될때마다 매번 다시생성되어 전달이 되고 있었던 것임. 
그리고 memo메서드는 props가 변경될 때만 컴포넌트가 리렌더링 하도록 최적화하기에 매번 리렌더링이 발생할 때마다 현재의 props와 과거의 props를 비교한다. 그래서 두개의 props가 서로 같은값인지 다른값인지를 판단해서 Todoitem을 리렌더링할지 말지를 결정하는데 이 memo메서드는 기본적으로 얕은 비교를 하기에 객체 타입의 값은 무조건 서로 다른 값이라고 판단을 한다. 그래서 결과적으로 하나의 Todoitem을 수정하면 다른 Todoitem에서도 memo메서드가 적용이 되었으나 모두 리렌더링해주는 것이다. 쉽게 말하면 App컴포넌트가 리렌더링이 되면 함수들모두 전부 다시생성되기에 결국 Todoitem가 props로 받는 함수들이 새롭게 전달이 되어 메모를 적용해도 리렌더링이 발생한다는 것임. 그렇기에 객체타입을 props로 받는 컴포넌트는 memo메서드를 적용한다고 해도 최적화가 되지 않는다. 이럴땐 두가지 방법이 있는데 첫번째로 App컴포넌트에서 함수들을 Memoization하여 리렌더링이 발생해도 다시생성되지 않도록하는 것이다. 그런데 이렇게하려면 다음시간에 배울 useCallback을 이용해야하기에 나중에 보고 이번엔 Todoitem컴포넌트의 memo함수안에 두번째 인수로 Callback함수를 전달해서 최적화 기능을 Customizing해주면 된다. 두번째 인수로 callback함수를 전달가능한데 보통은 생략하다 전달해주면 그순간 부터 memo메서드는 부모 컴포넌트가 리렌더링 될때마다 컴포넌트의 props가 바뀌었는지 스스로 판단하는게 아니라 callback함수의 매개변수로 과거의 props와 현재의 props를 전달해서 함수의 전달값에 따라 props가 바뀌었는지 안바뀌었는지를 판단한다. 그래서 이 callback함수에서 true를 반환하게 되면 props가 바뀌지 않았다고 판단하고 false를 반환하면 props가 바뀌었다고 판단한다. true를 반환하면 리랜더링을 하지말라는거고 false를 반환하면 리렌더링을 하라는 것이다. 그렇기에 이 callback함수안에 우리가 원하는 Todoitem컴포넌트가 갖는 props들 중에 onUpdate와 onDelete를 제외한 id, isDone, content, date만 바뀌었을때 리렌더링 해주면 되는 것이기에 

if(prevProps.id = nextProps.id) return false;
if(prevProps.isDone = nextProps.isDone) return false;
if(prevProps.content = nextProps.content) return false;
if(prevProps.data = nextProps.date) return false;

return true;

이렇게 해서 설정해주면 이제 저조건 안에서만 리렌더링 하게된다.

이렇게 컴포넌트를 인수로 받아서 해당 컴포넌트에 추가적인 기능(최적화나 Memoization)을 덧붙혀서 기능이 추가된 새로운 컴포넌트를 반환해주는 memo와 같은 메서드들을 리액트에선 고차컴포넌트(Higher Order Componenet, HOC)라고 부른다. 이걸 이용하면 한번 호출하는 것 만으로 컴포넌트에 새로은 기능을 부여할 수 있기에 복잡한 리액트 앱을 구축할때 괘나 자주쓰는 유용한 방법이다. 

그리고 memo 말고도 직접 만들 수 도 있기에 
https://patterns-dev-kr.github.io/design-patterns/hoc-pattern/
에서 확인해보자 

-----

10.4)useCallback과 함수 재생성 방지

최적화의 마지막으로 useCallback을 이용해서 불필요한 함수의 재생성을 방지해보자.

최적화를 할때 이제 앞으로 memo메서드를 매번 props를 확인해서 비교하면 매우 불편할 것이다. 게다가 props의 이름이 변경되기라도 한다면 memo메서드 안에도 바꿔줘야하고 새로운 props가 추가되면 또 추가해줘야하는 경우가 생겨 불편할 것이다.
그래서 이럴땐 그냥 onUpdate와 onDelete가 에초에 다시 생성되지 않도록 최적화하는게 조금더 좋은 방법일 수 있다. 이런 것을 가능하게 하는것이 useCallback이라는 리액트 hook이다. 
직접 사용해보자면, App컴포넌트로 가서 상단에 useCallback을 불러오고 컴포넌트 안에서 바로 return문 위에 useCallback을 호출하고 첫번째인수로 최적화하고 싶은 함수를(불필요하게 재생성하고 싶지 않은 함수) 인자로 넣어주고 두번째 인수로는 deps를 넣어주면 된다. 그러면 useCallback은 기본적으로 첫번째로 전달한 callback함수를 그대로 생성해서 반환을 해준다. 그러면 이것 또한 변수로 담아줄 수 있을 것이다. 그리고 이렇게 생성된 함수를 deps가 변경될때만 다시 생성되도록 최적화를 해준다(함수를 Memoization해준다는 의미임). 그렇기에 deps를 빈배열로 설정 해주면 컴포넌트가 마운트 될때만 함수를 한번 생성하고 그 다음엔 아무리 리랜더링이 되더라도 새롭게 생성하지 않는다. 이런 점을 이용하면 함수들을 다시 생성하지 않도록 최적화 할 수 있다.

useCallback()내에 익명함수로 생성해서 내부 코드를 복사해서 넣어준다. 그리고 두번째 인수로 빈배열을 넣어서 onDelete함수를 다시는 생성하지 않도록해주면 된다. 이제 이걸 const onDelete에 저장해주고 기존것은 지워주면 된다. 나머지 함수들도 최적화를 해주면 된다.  

이제 Todoitem컴포넌트에서 별도로 callback함수를 memo메서드로 전달하지 않아도 되고 이전처럼 export default memoTodoitem;으로 export만 해줘도 이제 된다.

주의 해야 할 점은 최적화는 언제하는가, 어떤것을 하는가가 중요한 기준이 된다. 최적화를 너무 이른타이밍에 해도, 너무 많은 것을 하려고 해도 문제가 있다.

최적화를 하는 시점은 언제가 좋은가?
보통 리액트앱을 최적화할 때에는 보통 하나의 프로젝트를 거의 완성한 상태에서 최적화를 하게 된다. 그래서 항상 기능을 구현하는게 먼저여야하고 기능이 완성이 되면 그 뒤에 최적화를 하는게 일반적인 방법이다. 왜냐면 최적화를 위해 useCallback과 같은 메서드를 적용하고 나면 새로운 기능을 추가하거나 수정하게 되면 최적화가 풀리거나 고장나는 경우도 생기기 때문임. 그렇기에 기능구현이 먼저, 마지막에 최적화하는 것이 좋다.

그럼 어떤 것이최적화의 대상이 되어야하는가? 
모든것을 적용하면 안되고 꼭 최적화가 필요할것 같은 연산, 함수, 컴포넌트에만 적용하는게 좋다. 예를 들어 Header컴포넌트처럼 매우 단순한 컴포넌트처럼 memo메서드를 적용했는데 이 memo메서드도 연산이 필요로 하는 메서드이다(props의 값을 비교한다거나, 메모리에 컴포넌트 값을 저장한다던가). 그런데 이렇게 최적화하는 컴포넌트가 별일도 하지 않는 컴포넌트라면 그냥 다시 리렌더링하는게 더 빠를수도 있다. 그렇기에 보통은 이런 사소한 컴포넌트를 모두 최적화하지 않고 대신 Todoitem컴포넌트처럼 유저의 행위에 따라 컴포넌트가 매우 많아질 수 있는 컴포넌트던가, 함수들을 매우 많이 가지고 있어 코드가 무거운 컴포넌트라면 그런 컴포넌트 한정으로 최적화를 하는 것을 권장한다.

최적화는 결국 꼭해야할것같은 애들만 해주는게 좋고 기능구현이 먼저고 최적화는 가장 마지막에 해라.
----

섹션11. Context

11.1) Context란?

컴포넌트간의 데이터 전달을 훨씬 편하게 만들어주는 리액트 context에 대해서 알아보자.
React Context는 props를 대체해서 컴포넌트간의 데이터를 전달할 수 있게 해주는 또하나의 방법으로 기존의 props가 갖고 있던 단점을 해결하기 위해 존재한다. 먼저 props는 부모에서 자식으로만 값을 전달할 수 있었다. 그렇기에 데이터를 컴포넌트의 계층구조상에서 한단계 아래에 전달하는 것은 아무런 문제가 없었다. 그러나 컴포넌트의 계층구조가 두단계 이상 깊어지면 App -> child A -> child B 로 전달하지 않고 App -> child B로 바로 전달하는 것은 불가능 하다. 위에 말했듯이 props란 부모에서 자식으로만 전달이 가능하기 때문이다. 이럴땐 어쩔 수 없이 중간에 child A가 중간다리 역할을 해줘야만 한다. 이전에 Todo List 앱을 만들때도 수정, 삭제를 할때 onUpdate나 onDelete같은 함수들을 todoitem컴포넌트에게 전달했어야 했는데 App컴포넌트와 Todoitem컴포넌트는 부모, 자식 관계가 아니라서 중간에 List컴포넌트가 다리역할을 해줘야한 했었다. 그래서 우리가 props를 이용하게 되면 어쩔수 없이 중간 다리를 거쳐서 전달해야 하는 경우가 많은데 이것 물론 좋은 방법은 아니다. 물론 지금은 List컴포넌트하나기에 문제가 크지 않을 수 있으나 만약 서비스의 규모가 커지게 되면서 App컴포넌트와 Todoitem컴포넌트 사이에 매우 많은 컴포넌트가 생성이 된다면 상상하기 힘들 만큼 컴포넌트를 거쳐서 데이터를 전달해야 하기에 props의 이름이 중간에 바뀌는 경우가 생기면 모든 컴포넌트를 뒤져가면서 찾아야한다. 이런 상황을 props가 드릴처럼 땅을 파고 내려가는 것같다고 해서 props drilling이라고 한다. 이것을 해결하는 방법이 react의 context이다.

context는 데이터들을 보관하는 데이터 보관소 역할을하는 객체이다. 그래서 context를 생성한 다음에 원래 자식 컴포넌트에게 전달하던 데이터, 함수들을 context에 보관해두면 이제 props에 보관하지 않고 direct하게 context를 통해 필요한 data를 공급해줄 수있다. 그렇게 하면서 props drilling을 해결할 수있게 된다. 그리고 이런 context는 여러개 생성하는 것도 당연히 가능하다. 

다음 섹션도 동일하게 Todo리스트 프로젝트를 통해서 사용할것이다.
-----

11.2) Context 사용하기

Context를 이용해서 Todo List의 props drilling을 해결해보자.
Todo List를 보면 onUpdate, onDelete 함수는 지금 현재 Todoitem컴포넌트에게 전달이 되어야 하기 때문에 일단 App컴포넌트의 return문 안에서 List컴포넌트에게 전달이 되고 또 List컴포넌트는 Todoitem컴포넌트에게 전달을 하고 있기에 결론적으로 props drilling이 발생하고 있다고 할 수 있다. 그래서 지금 발생한 props drilling을 해결해보기 위해서 context를 사용해보자면, 먼저 App.jsx파일에서 새로운 context를 생성하기 위해 import문에 createContext를 react에서 불러오고 컴포넌트 밖에, reducer함수 아래에 const todoContext에 우리가 불러온 createContext메서드를 호출해서 넣어주자. 이렇게 해서 새로운 context객체를 만들었는데 이 context는 보통 컴포넌트의 외부에 선언을 하게 된다 . 만약 App컴포넌트 안에 선언을 해주면 문제가 발생하는 것은 아니지만 App컴포넌트가 리렌더링이 될 때마다 계속해서 해당 코드를 실행하게되기에 계속 새로운 context를 생성하게 된다. 그런데 context의 역할은 데이터를 하위 컴포넌트에게 공급만 해주면 되기에 궂이 App컴포넌트가 리랜더링 될 때마다 다시 생성될 필요는 없다. 그렇기에 정말 특별한 상황이 아니면 보통은 컨텍스트 외부에 선언을 한다.

그럼 이 context내부에는 어떤 값이 있을지 모르기 때문에 console.log로 todoContext를 console에 출력해보자.
그러면 방금 생성한 context객체가 보이는데 굉장이 여러개의 properties를 갖는 객체라는 것을 알 수 있는데 그 대부분은 내부적인 동작을 위해 존재하기 때문에 모든 properties에 대해서 알 필요는 없다. 대신 provider라는 property만 잘 알아두면 된다. provider는 context가 공급할 데이터를 설정하거나 context에 데이터를 공급받을 컴포넌트들을 설정하기 위해서 우리가 사용하는 property인데 이건 사실 컴포넌트이다. 그래서 우리가 <todoContext.Provider/>로 렌더링도 가능하다. 사용법은 현재 props를 받고 있는 컴포넌트를 감싸서 선언하면 된다. 그러면 Provider컴포넌트 아래에 있는 모든컴포넌트들은 todoContext에 데이터를 공급받을 수 있는데, 이때 공급받을 데이터를 어떻게 설정하느냐면 Provider컴포넌트에게 value속성으로 전달해주면 된다. 우리는 todos, onCreate, onUpdate, onDelete를 전달할 것이기에 객체 형태로 전달해주자.
이제 Provider컴포넌트의 모든 자식, 모든 자손 컴포넌트들을 value 속성으로 설정한 Context가 공급하는 값들을 direct로 꺼내와서 언제든지 사용할 수 있는 상태가 된다. 

그렇기에 Editor컴포넌트와 List컴포넌트를 Provider컴포넌트로 감싸도록 설정해주면 이 안에 있는 컴포넌트들이 데이터를 공급받아 이용할 수 있다고 보면 된다. 개발자도구의 components를 들어가보면 계층구조를 살펴보면 context.Provider가 계층구조에 추가된 것을 볼 수 있고 Editor컴포넌트와 List컴포넌트를 감싸도록 구성된 것을 볼 수 있다. 그리고 이때 Provider컴포넌트를 클릭해서 어떤 데이터를 갖고 있는지 확인해보면 value로써 공급한 데이터들을 확인할 수 있다.
이제 데이터를 공급하는것은 모두 완료가 되었고 이제 꺼내서 사용하는 방법을 알아보자.
Editor컴포넌트부터 Context로 부터 제공받는 값을 이용할 수 있도록 바꿔보자.
이 컴포넌트에게 props로 전달하던 onCreate함수는 context를 통해서 전달받기에 지워줘도 된다(태그 내부에 속성으로 전달하던 값지우기).
그리고 Editor컴포넌트로 들어가서 props로 데이터를 받지않고 context로 데이터를 값을 꺼내오도록 설정해야하는데 그럴려면 새로운 리액트 Hook인 useContext hook을 불러와야한다. 그리고 컴포넌트 안에서 const data = useContext()를 호출하고 인수로는 데이터를 불러오고자 하는 context를 직접 넣어주면 되는데 우리가 데이터를 불러오고자 하는 context는 App.jsx에서 선언해둔 todoContext인데 이걸 export하고 있지 않기에 Editor.jsx에 가져올 수 없기에 일단은 App.jsx에서 const todoContext = .. 이 부분을 export const todoContext = ..으로 변경해주자. 그리고 나서 Editor.jsx에서 import문으로 todoContext를 App.jsx로 부터 불러오고 이걸 useContext의 인수로 전달하면 된다. 그러면 useContext라는 리액트 Hook은 인수로 전달한 context로부터 공급된 데이터를 반환해주는 함수이다. 그렇기에 data라는 변수에는 todoContext가 전달한 값들이 존재할 것이다. 이걸 console.log를 통해서 출력을 해보면 App컴포넌트에서 Provider에게 value속성으로 전달해줫던 props값들이 다 Editor컴포넌트로 잘 공급되는 것을 볼 수 있다. 이제는 data로 불러오지 말고 구조분해 할당으로 [onCreate]를 받아와보자. 

동일하게 다른 컴포넌트도 context로 값을 받아올 수 있도록 해보자(받아올 때는 필요한것만 구조분해할당하여 사용하자).

근데 이렇게 보면 memo로 설정했던 최적화가 풀린것을 볼 수 있다. 다음에 이걸 해결해보자. 

기본적으로 context는 이렇게 사용한다고 알아두고 가자.

------

11.3) Context 분리하기

context적용 이후에 최적화가 풀리는 이유와 해결법을 알아보자
사실 Provider도 컴포넌트이기에 App컴포넌트로 부터 value 속성으로 제공받는 객체가 바뀌게 되면 당연히 리랜더링이 발생한다. 그런데 이 객체가 바뀌는 이유는 todos state가 변경되기에 객체를 다시 생성해서 넘겨 주기 때문임. 그래서 이 Provider컴포넌트도 리렌더링이 발생하기에 하위 컴포넌트 입장에선 부모 컴포넌트가 리렌더링 되는 상황이기에 자식컴포넌트도 리렌더링되게 된다. 그런데 이전에 최적화를 진행하기 위해서 자신이 받는 props가 바뀌지 않으면 리렌더링이 발생하지 않도록 했는데 지금은 왜 리렌더링이 발생하는 것일까? 그 이유는 새로운 todo를 추가하거나 기존 todo를 추가, 삭제하게 되면 App컴포넌트의 todos state가 변경이 되어 App컴포넌트가 리렌더링이 되게 될텐데 그때 이 Provider컴포넌트에게 value 속성으로 전달하는 이 객체 자체가 다시생성이 되기 때문임. 그렇기에 Todoitem컴포넌트에서 useContext를 호출해서 todoContext로부터 불러온 객체 자체가 다시 생성이 되기에 Todoitem컴포넌트가 리렌더링이 발생하게 되는 것이다. 왜냐면 memo를 적용했더라도 useContext로 부터 불러온 값이 변경이 되면 props가 변경된것과 동일하게 리렌더링이 발생되기 때문임. 이걸 해결하는 방법은 무엇일까? 이 문제는 todoContext를 두개의 context로 분리해서 해결할 수 있다. 그래서 todos처럼 state임으로 변경될수 있는 값들은 todoStateContext를 만들어 새로운 Context로 공급을 하고 반대로 onCreate나 onUpdate나 onDelete같은 변경되지 않는 함수들은 todoDispatchContext라고 새로 만들어서 분리해서 공급해주면 된다. 
이렇게 해주면 context가 두개로 분리가 되었기에 todos state가 변경이 되더라도 todoList컴포넌트만 불러다 쓰기에 다른 컴포넌트들은 리렌더링 되지 않을 것이고 todo List컴포넌트만 리렌더링 될것이다. 물론 부모컴포넌트가 리렌더링 되면 모두 리렌더링되는것은 맞으나 memo를 적용했기에 리렌더링 되지 않을 수 있는 것이다. 

기존 context를 지우고 export const todoStateContext = createContext로 만들고 동일하게 export const todoDispatchContext = createContext로 만들어주자. 그리고 이제 Provider도 전체를 다보내지 않기에 todoContext.Provider를 지워주고 먼저 todoStateContext.Provider를 먼저 렌더링하도록 설정하고 value로 todos를 전달해주자. 그리고 그 아래에 todoDispatchContext.Provider를 두번째로 묶도록 설정하고 value속성에 onCreate, onUpdate, onDelete를 전달해주자. 그런데 이때 dispatchContext에 value로 전달하는 객체도 App컴포넌트의 todos state가 변경되면서 리렌더링이 발생하면 새롭게 다시 생성할 것이다 그래서 다시는 생성하지 않도록 useMemo를 사용해주자.
그래서 먼저 App컴포넌트의 최상단에 useMemo를 불러오고 return문위에(외부) 세개의 함수를 다시 생성되지 않도록만들 것이기에 memoizedDispatch로 생성해서 useMemo를 호출하고 callback함수로 객체를 return할 것인데 onCreate와 onUpdate와 onDelete를 가진 객체를 return해주자. 그리고 두번째 인수 deps로는 [] 빈배열을 넣어서 마운트 이후에 다시는 생성되지 않도록 설정하자. 그러면 이제부터 DispatchContext가 공급하는 값은 절대로 바뀌지 않을 것이다. 

이제 각 컴포넌트로 들어가서 Context에서 데이터를 공급받아 사용해주자.

주의할 점은 이전엔 객체로 하나로 묶어서 공급을 했었는데 todoStateContext는 value로 그냥 todos를 전달했기에 객체가 아니기에 구조분해 할당이 아니라 그냥 받아서 사용해야 한다.

----

섹션 12 프로젝트3. 감정 일기장

12.1) 프로젝트 소개 및 준비 

이제 모두 배우고 나면 , 리액트 앱에 외부 폰트를 적용, 이미지를 사용, 최적화하는 방법, 다양한 페이지 제공, 버튼처럼 자주 쓰이는 요소를 컴포넌트로 모듈화하는 방법, 클라우드 서비스를 이용해서 웹에 배포하는 방법까지 배울 것임.

12.2) 페이지 라우팅1 . 소개

리액트 앱에서 여러개의 페이지를 제공하도록해주는 페이지 라우팅에 대해서 배우자.
여태 만들었는 리액트 앱과는 다르게 여러개의 페이지로 서비스를 구성해야한다. 모든 일기가 피드형태로 나타나는 Indexpage와 새로운 일기를 작성할 수 있는 Newpage, 일기의 상세페이지역할을하는 Diarypage가 존재한다. 그렇기에 리액트 앱이 다양한페이지를 제공할 수 있도록 페이지 라우팅을 설정해야하는데 페이지 라우팅이란 경로에 따라 알맞는 페이지를 화면에 렌더링 해주는 것을 의미한다. 구체적으로 말하자면 사용자와 브라우저 웹서버가 있을때 사용자가 특정 페이지에 접속하고 싶을때 브라우저의 URL로 요청을 보낼때 웹서버가 브라우저에게 요청에 맞는 페이지를 반환하고 브라우저는 그 페이지를 렌더링해주는 이러한 과정을 페이지 라우팅이라고 한다. 그러면 이런 페이지 라우팅은 어떤 원리로 이루어질까. 전통적인 웹서비스들은 먼저 웹서버가 사용자에게 제공해줘야 하는 모든 페이지에 해당하는 HTML을 모두 갖고 있다. 그래서 index.html, blog.html, setting.html등의 모든 웹페이지들은 html으로써 모두 갖고 있는 것임. 이때 브라우저에서 어떤 페이지를 요청하면 그 요청에 맞는 페이지를 찾아서 그대로 반환해준다. 그러면 브라우저는 서버로부터받은 html파일을 그대로 렌더링하게 된다. 그래서 이런식으로 에초에 서버가 사용자들에게 제공할 여러개의 페이지를 미리갖고 있는 방식을 여러개의 페이지를 갖는 어플리케이션이다 라고 해서 Multi Page Application(MPA)라고 한다. 이 MPA는 동작방식이 매우 직관적이라 현재까지도 많은 서비스들이 이용하는 전통적인 방식이다. 그리고 이런 MPA방식에서 브라우저가 새로운 페이지를 요청했을때 서버측에서 미리 완성해놓은 html파일을 보내주면 브라우저가 그걸 그대로 렌더링하는 방식은 서버측에서 미리 렌더링해준다 해서 Server Side Rendering이라고 한다. 하나 헷갈리면 안되는게 MPA와 ServerSideRendering은 같은 말이 아니라 서버가 여러개의 html을 갖고 있는걸 MPA라고 하는거고 그런 MPA방식에서 브라우저 페이지를 요청했을때 미리 완성되어 있는 페이지를 응답해주는 방식을 서버 사이드 렌더링이라고 한다고 이해하면 된다. 
정리하자면 대다수의 전통적인 웹서비스들은 MPA방식으로 서버가 다수의 웹페이지를 보유하고 있고 브라우저가 요청을 보내면 ServerSideRendering방식으로 미리 만들어진 페이지를 응답한다고 그런에 리액트앱은 이런 MPA방식을 따르지 않는다. 왜냐면 이런MPA방식은 페이지의 이동을 빠르게처리하기힘들기 때문이다. 그렇기에 리액트가 제공하는 쾌적하고 빠른 페이지 이동을 제공하기 힘들기 때문이다. 
구체적으로 보자면 MPA방식의 서비스에서 유저가 블로그 페이지에 접속하고 있을때 링크나 버튼을 클릭해서 페이지를 이동하면 웹서버는 실시간으로 적절하 html파일을 찾거나 실시간으로 만들어서 반환해주게 된다. 그러면 브라우저는 원래 있던 블로그 페이지를 제거해버리고 새롭게 받은 setting페이지를 렌더링하게되면서 페이지 이동이 완료된다. 쉽게 말하면 페이지를 이동할 때마다 원래 랜더링해뒀던 페이지는 다시 다 지우고 아예 새로운 페이지를 받아와서 화면에 처음부터 다시 렌더링해주게 되는데 이러한 과정에서 페이지가 새로고침되는것 처럼 한번 깜빡이게 된다.  그렇기에 이렇게 MPA방식으로 개발된 웹서비스들은 페이지가 이동될때 이전페이지와 이후페이지의 공통이되는 요소가 있더라도 페이지 이동시에 원본을 전부 제거하고 페이지를 처음부터 새로 다시 그리기 때문에 비효율적으로 페이지를 이동하고, 이전 페이지를 제거하고 새로운 페이지를 렌더링하는 과정에서 화면이 깜빡이면서 새로고침되는 등의 그닥 매끄럽지 않은 페이지 이동을 제공한다. 게다가 모든 사용자들이 페이지를 이동할 때마다 새로운 페이지를 달라고 서버에 요청을 하는데, 서버 입장에선 모든 요청을 하나하나 다 처리해주기 때문에 아주 많은 페이지 요청이 들어오면 서버의 부하가 매우 크다는 단점이 있다. 그래서 아주 심할 경우엔 접속 대기열이 생성되기도 하고 더 심각한 경우엔 사이트가 터져버리는 현상이 발생하기도 한다. 그렇기에 리액트앱은 MPA방식이 아니라 Single Page Application(SPA)라는 MPA와는 반대되는 방식으로 작동하게 된다. 그리고 그럼으로써 페이지 이동을 매끄럽고 효율적으로 처리하고 다수의 사용자가 몰리더라도 서버의 부하가 심해지지 않는 방식으로 동작하게 되는데 이런 SPA방식에 대해 말해보자면, 우선 SPA라는 것은 단일 페이지 어플리케이션을 의미하는데 그래서 SPA방식으로 구현되는 리액트 앱서버는 페이지를 딱 하나만 갖고 있게 된다. 그래서 여기에 추가로 우리가 만든 리액트 컴포넌트나 기타 유틸등이 작성되어 있는 JS파일도 함께존재한다. 그래서 App.jsx나 Header.jsx 같은 파일들이 여기에 존재하게 되는 것이다. 그래서 SPA방식으로 작동하는 리액트 앱서버에 사용자가 접속을 요청하면 어떤 경로로 요청했던간에 관계없이 리액트 앱서버는 브라우저에게 index.html파일을 보내주게된다. 그리고 이때 index.html파일은 리액트에 원래 존재하던 이 파일이다(index.html 사진 넣기). 이 파일은 전에 리액트앱의 빈 껍데기역할을 한다고 했는데 그렇기에 화면에 아무것도 렌더링하고 있지않고 대신에 스크립트 태그를 이용해서 Main.jsx라는 리액트 코드를 가동시키는 역할만 하고 있다. 그래서 브라우저는 지금까지 받은건 index.html밖에 없으니까 빈껍데기인 index.html을 렌더링하게 된다. 그래서 빈 화면이 렌더링이 되는데 이때 리액트 앱서버는 후속으로, 우리가 만든 자바스크립트 파일들(리액트 컴포넌트 , 기능들이 작성되어 있는 파일들)을 하나의 파일로 묶어서 브라우저에게 추가로 전달을 해준다. 그리고 이때 참고로 이렇게 여러개의 자바스크립트 파일들을 묶어주는 행위를 "번들링" 이라고 한다. 그래서 번들링되어 브라우저에게 전달되는 자바스크립트 파일을 실무에선 번들파일이라고 부른다. 그리고 이런 번들링과정은 우리가 리액트앱을 사용할때 이용하던 vite가 담당하게 된다. 그래서 결론적으로 직접 작성하는 모든 컴포넌트와 기타 모든 자바스크립트 파일들은 vite에 의해서 하나의 자바스크립트 파일로 번들링되어 브라우저에게 추가로 전달되게 된다. 그러면 브라우저는 이렇게 전달된 번들파일을 직접실행한다. 그러면 우리가 앞서 봤던 Main.jsx가 브라우저에서 가장먼저 실행이되면서 이파일에 있던 render메서드가 호출이 되면서 App컴포넌트를 화면에 실제 렌더링하게 된다. 그러면서 우리가 작성한모든 컴포넌트들이 화면에 렌더링하게된다. 그리고 참고로 브라우저에서 이렇게 자바스크립트파일을 실행해서 화면을 직접 렌더링하는방식을 클라이언트 측인 브라우저에서 직접 렌더링을 처리한다고 해서 ClientSideRendering이라고 부른다. 앞서 살펴본 ServerSideRendering과 반대되는 개념이다. 그리고 이 번들파일은 우리가 직접 작성한 모든 리액트 컴포넌트들이 하나의 파일로 묶인 자바스크립트 파일이기에 사실상 우리는 이 파일을 리액트 앱이라고 부를 수 있다. 이렇게 해서 리액트가 실제로 화면에 렌더링되는 과정을 봤다.

1. 리액트는 MPA(Multi Page Application)방식을 따르지 않는다.
2. 리액트는 SPA(Single Page Application)방식을 따른다.
3. 화면에 렌더링 하는 요소의 정보를 html에 직접 작성이 아니라 JS파일에 컴포넌트라는 리액트 문법으로 작성한다.

리액트의 렌더링 과정
1. index.html을 띄운다.
2. 모든 js파일을 전달하기 편하게 번들링 하여 번들파일로 전달한다.
3. 브라우저에서 번들링된 js파일을 직접 실행해서 컴포넌트를 직접 렌더링한다.
4. 이때 번들링된 파일에는 우리가 리액트 문법으로 작성한 모든 정보들이 담겨 있기에 이 파일을 리액트 앱이라고 부를 수 있다.

그리고 이 리액트 앱은 실제로 브라우저에서 동작하게 된다.

SPA 방식에선 사용자가 링크나 버튼을 클릭해서 setting페이지로 페이지 이동이발생한다면 MPA방식과는 달리 서버에는 요청을 보내지 않는다. 대신 처음에 받은 서버로 부터 받은 리액트 앱을 이용해서 자체적으로 브라우저내에서 새로운페이지에 필요한 컴포넌트들로 화면을 교체한다. 그럼으로써 아무런 요청도 없이 브라우저가 스스로 페이지를 이동시킨다. 이렇게 할 수 있는 이유는 리액트앱에는 모든 자바스크립트 파일이 번들링 되어 있기 때문에 리액트 문법으로 작성한 모든 페이지 정보도 다 포함되어 있기 때문이다. 그래서 블로그 페이지에서 세팅 페이지로 이동한다면 리액트 앱에선 화면의 모든 요소들이 컴포넌트로 이루어져있기 때문에 헤더같은 공통요소는 그대로 두고 블로그 아티클같은 변경이 필요한것들만 갈아 끼우면되기에 페이지를 신속하게 업데이트 할 수 있다. 그리고 앞서 살펴본것처럼 MPA방식처럼 새로고침이 발생하는것에 비해서 효율적으로 페이지를 업데이트 할 수 있다.

결론적으로 리액트를 이용하면 더 쾌적하고 빠르게 페이지 이동이 가능하다. 그이유는 SPA이기 때문이다.

12.3) 페이지 라우팅2. 라우팅 설정하기
리액트 앱의 페이지 라우팅을 도와주는 추가적인 라이브러리를 설치하고 감정일기장 프로젝트에 다양한 라우팅을 설정해보자.
이번에 이용할 라이브러리는 리액트 라우터로 npmjs.com에 정식으로 등록된 라이브러리로 현재 대다수의 리액트 앱이 사용하고 있는 대표적인 라이브러리이다. 그래서 실제 2024년을 기준으로 최근 6개월간 주간 설치 횟수가 500만에서 1000만까지 넘기는 인기를 자랑한다. 그리고 그 인기만큼 강력하고 다양한 기능을 안정적으로 제공하기에 리액트 라우터를 설치하고 직접 사용해보자. 
이제 리액트 앱(sec12)을 열고 터미널에 npm i react-router-dom으로 react-router-dom라이브러리를 설치해주자. 그러면 added 3 packages, and audited 282 packages in 2s라고 하면서 새로운 라이브러리가 잘 추가되었다고 메세지가 출력이 되고. package.json에도 dependencies에도 6점때 버전으로 잘 추가되어 있는 것을 볼 수 있다(6점때 버전보다 하위이면 에러가 발생할 수 있음, 6점때 혹은 그 이상으로만 설치해야 에러가 안생김). 
이제 react-router를 이용해서 페이지 라우팅기능을 사용 해보자. main.jsx에서 리액트 라우터 돔에서 브라우저라우터를 불러오자.

import { BrowserRouter } from 'react-router-dom'

그리고 이렇게 불러온 브라우저 라우터가 이제는 App컴포넌트를 감싸도록, App컴포넌트의 부모 컴포넌트가 되도록 감싸줘야한다. 브라우저 라우터는 브라우저의 현재 주소를 저장하고 감지하는 역할을 한다. 그렇기에 브라우저 라우터로 앱 컴포넌트를 감싸주면 리액트앱의 모든 컴포넌트가 현재 브라우저의 주소를 가져다 쓸 수있고 주소의 변화를 감지할 수도 있게 된다. 그래서 이떄 실제 브라우저에서 개발자도구를 열어서 컴포넌트 탭에 들어가보면 브라우저 라우터라는 컴포넌트가 모든컴포넌트를 감싸고 있는 root컴포넌트로 설정된것을 볼 수있고 클릭해서 보면 state를 이용해서 주소와 관련된 정보를 보관하는 것을 볼 수있다. 그리고 브라우저 라우터에 보관되는 모든 데이터들은 옆의 컴포넌트 트리를 다시보면 Navigation.Provider나 Location.Provider같은 context객체의 Provider 컴포넌트를 이용해서 App컴포넌트의 모든 자식 컴포넌트에게(우리가 앞으로 만들 모든 컴포넌트에게) context를 통해서 공급되고 있는것 또한 확인할 수 있다.

정리해보자면 브라우저 라우터로 App컴포넌트를 감싸주면 리액트 앱의모든 컴포넌트 들이 페이지 라우팅과 관련된 모든 데이터를 공급받아 사용할 수 있게 된다.

다음으로 App.jsx로 가서 페이지를 직접 나눠보자. 
1. /index 경로에서는 모든일기를 조회하는 Home 페이지를 렌더링하도록 설정
2. /new 경로에서는 새로운 일기를 작성하는 New 페이지를 렌더링하도록 설정
3. /diary 경로에는 일기를 상세하게조회하는 Diary 페이지를 렌더링하도록 설정

먼저 각각의 페이지 역할을 하게될 컴포넌트를 먼저 생성해보도록 하자. 리액트에서는 모든 요소를 컴포넌트로 나누기에 페이지도 컴포넌트로 나뉜다. src/pages라는 디렉터리를 생성하고 Home.jsx, New.jsx, Diary.jsx를 생성해주자. 그리고 각각 파일에 임시로 이름을 출력하는 컴포넌트를 생성해주자.



























































12.4) 페이지 라우팅3. 페이지 이동

12.5) 페이지 라우팅4. 동적 경로

12.6) 폰트, 이미지 ,레이아웃 설정하기

12.7) 공통 컴포넌트 구현하기

12.8) 일기 관리 기능 구현하기 1

12.9) 일기 관리 기능 구현하기 2 

12.10) Home 페이지 구현하기 1. UI

12.11) Home 페이지 구현하기 2. 기능

12.12) Home 페이지 구현하기 3. 회고

12.13) New 페이지 구현하기 1. UI

12.14) New 페이지 구현하기 2. 기능

12.15) Edit 페이지 구현하기

12.16) Diary 페이지 구현하기

12.17) 웹 스토리지 이용하기

12.18) 배포 준비하기

12.19) 배포하기

13.1) 마치면서

